## 渲染页面

- 首次渲染
- 原地刷新
- 重新打开

### 重要过程

> A、键入导航

---

- 1、DNS 查找 （查找域名服务器 的 IP）

  - DNS，域名服务器系统，是互联网的电话簿， DNS 将各域名转换为 IP 地址，浏览器向该 IP 地址发出 HTTP 请求， 加载资源。

    - 每个设备对应唯一 IP 地址，通过该 IP，其他计算机可找到此设备
    - 通常一个页面仅需要 DNS 查找一次，对不同页面指向的主机名分别查找。

  - 查找——将域名转为 IP 地址后。

    ```
    初始化请求时，由于这个 IP 地址未曾被缓存，通常会通过 DNS 域名服务器查找 IP；
    ```

    ```
    初始化请求之后，这个 IP 地址会被缓存一段时间，这样可以从缓存检索到 IP 地址，节省了 DNS 查找的时间，并减少带宽/CPU 消耗
    ```

  - 性能问题
    - 查找过程于性能而言是一个问题，特别是移动网络下，这中间通信节点（手机、信号塔、域名服务器）的实际距离会导致等待时间变长

---

- 2、TCP Handshake （与服务器建立联系）

  - 三次握手：SYN、SYN-ACK、ACK
  - 两端尝试通信——浏览器和服务器在正式通信之前，通过上层协议 https 可以协商网络 TCP 套接字链接的一些参数

---

- 3、TLS 协商 （针对 HTTPs 的加密通信）

  - 为了在 HTTPS 上建立安全连接，TLS 是必须的。TLS（传输层安全）是更为安全的升级版 SSL
  - 不使用 SSL/TLS 的 HTTP 通信，就是不加密的通信。SSL/TLS 协议的基本思路是采用公钥加密法，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。

---

- 4、通信达成

  - 浏览器与服务器建立连接完成！浏览器代表用户发送初始化 HTTP GET 请求，通常是一个 html 文件，服务器收到后，用相关的相应头和 html 内容回复

    - 初始请求的响应接收到的第一个 HTML 包（响应包）通常 14KB，这是<mark>慢开始</mark>的一部分，

      ```
      注：
        慢开始 ————
          a. What：：TCP slow start, 是一种均衡网络连接速度的算法，这个过程会逐渐增大发送数据的数量，直到达到网络的最大宽带数量。
          b. How：：收到初始包之后，服务器会将下一个响应包的大小加倍的 约等于 28KB（14KB x 2），后续的包依次是前面的二倍，直至达到最大值，或拥塞（防止过多的数据注入到网络中，避免出现网络负载过大的情况）
          c. Why：：TCP慢开始就是初始响应14KB的原因（初始14KB响应可视为web性能优化的一个重点）
      ```

---

- 5、解析数据

  - 收到第一块数据后，浏览器开始<mark>解析</mark>工作，即使请求页面的 HTML 大于初始的 14KB 数据包，浏览器也尝试开始解析，并根据数据渲染。（所以前 14kb 中包含开始渲染页面所需内容，是十分高效的，至少包含页面模版即 css && html，这也是性能优化的重点）

    ```
      注：
      a. 解析 ——— 接收到的数据 ——> DOM + CSSOM（通过渲染器把 DOM 和 CSSOM 在屏幕上绘制成页面）

    ```

  - 解析过程：

    - 1）<u> 构建 Dom 树</u>。

      - what：处理 HTML 标记并构造 DOM 树，dom 树是一个反映各标签关系的层次结构；
      - why：dom 节点数量越多，构建 dom 树所需时间也就越长；文档格式良好，则解析会简单而快速（web 性能优化重点之一）。
      - 遇到非阻塞资源 ——> 如图片、css 文件，浏览器会去请求这些资源继续解析；<br/>遇到阻塞资源 ——> 如 script 标签(特别是没有 <mark>defer 或 async </mark> 属性)，会阻塞渲染 并停止 HTML 的解析。（尽管浏览器的预加载扫描器加速了这个过程，但过多的脚本仍然是一个重要的瓶颈）


    - 2）<u> 预加载扫描器</u>
      - how：浏览器构建 DOM 树时，这个过程占用了主线程。这种情况下，预加载扫描器将解析可用的内容并请求高优先资源（web 字体、css、js）。
      - why ：预加载扫描仪提供的优化减少了阻塞


        ```
          <link rel="stylesheet" src="styles.css"/>
          <script src="myscript.js" async></script>
          <img src="myimage.jpg" alt="image description"/>
          <script src="anotherscript.js" async></script>

        ```

        在上面例子中，当主线程在解析 HTML 和 CSS 时，预加载扫描器将找到脚本和图像，并开始下载它们。为了确保脚本不会阻塞进程，当 JavaScript 解析和执行顺序不重要时，可以添加 async 属性或 defer 属性。

        等待获取 CSS 不会阻塞 HTML 的解析或者下载，但是它的确阻塞 JavaScript，因为 JavaScript 经常用于查询元素的 CSS 属性。

    - 3）<u> 构建CSSOM树</u>
      - What： CSSOM对象模型和DOM相似，DOM 和CSSOM是两棵树，他们是独立的数据结构。
      - How：浏览器将css规则转换为样式映射，而后浏览器遍历css中的每个规则集，根据css选择器创建具有父子兄弟关系的节点树。<br/> 构建CSSOM非常非常快，在web性能优化方面，它是可轻易实现的，因为创建CSSOM的总时间通常小于一次DNS查找所需的时间

    - 4）<u> Javascript编译</u>

     - js脚本先被解析为抽象语法树（AST，Abstract Syntax Tree），接着一些浏览器引擎使用AST，并把它传递到解释器中，输出到主线程上执行的字节码。这就是所谓的Javascript 编译

---

- 6、渲染

  - 总体步骤（<mark>样式 Style</mark>、<mark>布局 Layout</mark>、<mark>绘制 Paint</mark> ，某些情况下还包括 <mark>合成 Compositing</mark>）—— <br/>
    a.前面解析出来的 CSSOM 和 DOM 树组合成一个 render 树，<br/>
    b.然后计算每个可见元素的布局，并绘制到屏幕上。<br/>
    c.某些情况下可以将内容提升到他们自己的层进行合成，通过 GPU（不是 CPU）绘制屏幕的一部分来提高性能，释放主线程。

    - 1、样式 Style：DOM + CSSOM ——> Render 树，Render 树保存所有具有内容和计算样式的可见节点——将所有相关样式匹配到 DOM 树中的每个可见节点，并根据 CSS 级联确定每个节点的计算样式。
    - 2、布局 Layout：在 render 渲染树上计算每个节点的几何尺寸（宽、高、位置），开始布局。为了确定每个对象的确切大小和位置，浏览器从渲染树的根（<body>）开始遍历它。（回流则是对页面任何后续大小和位置的确定）

    ```
    注意区分：
      布局 —— 第一次确定节点的大小和位置称为
      回流 —— 随后对节点大小和位置的重新计算
      （假设初始布局发生在返回图像之前。由于我们没有声明图像的大小，因此一旦知道图像大小，就会有回流）
    ```

    - 3、绘制 Paint：最后一步是将各个节点绘制到屏幕上。在绘制或光栅化阶段，浏览器将在布局阶段计算的每个框转换为屏幕上的实际像素，并将元素的可视部分（包括文本、颜色、边框、阴影和替换的元素（如按钮和图像））绘制到屏幕上。浏览器需要很快完成这一阶段。
      - 为了确保重绘的速度比初始绘制的速度更快，屏幕上的绘图通常被分解成数层。如果发生这种情况，则需要进行合成，即绘制可以将布局树中的元素分解为多个层
      - 绘制可以将布局树中的元素分解为多个层。将内容提升到 GPU 上的层（而不是 CPU 上的主线程）可以提高绘制和重新绘制性能（有一些特定的属性和元素可以实例化一个层，包括 video 和 canvas，任何 CSS 属性为 opacity、3D 转换、will-change 的元素，还有一些其他元素）

    （层确实可以提高性能，但是它以内存管理为代价，因此不应作为 web 性能优化策略的一部分过度使用。）


      - 4、合成Compositing：当文档的各个部分以不同的层绘制，相互重叠时，必须进行合成，以确保它们以正确的顺序绘制到屏幕上，并正确显示内容
       - 当页面继续加载资产时，可能会发生回流（回想一下我们迟到的示例图像），回流会触发重新绘制和重新组合。如果我们定义了图像的大小，就不需要重新绘制，只需要重新绘制需要重新绘制的层，并在必要时进行合成。但我们没有包括图像大小！从服务器获取图像后，渲染过程将返回到布局步骤并从那里重新开始。 （建议设置宽高，高效回流）

> ### 参考文章：

| 文章名                     | 地址                                                                                          |
| -------------------------- | --------------------------------------------------------------------------------------------- |
| 渲染页面：浏览器的工作原理 | https://developer.mozilla.org/zh-CN/docs/Web/Performance/How_browsers_work#%E5%AF%BC%E8%88%AA |
| DNS security               | https://www.cloudflare.com/zh-cn/learning/dns/dns-security/                                   |
